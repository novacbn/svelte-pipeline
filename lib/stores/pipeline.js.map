{
  "version": 3,
  "sources": ["src/stores/pipeline.ts"],
  "sourcesContent": ["import type {Readable} from \"svelte/store\";\n\nexport enum PIPELINE_MODES {\n    evaluate = \"MODE_EVALUATE\",\n\n    validate = \"MODE_VALIDATE\",\n}\n\nexport enum PIPELINE_RESULT_TYPES {\n    error = \"RESULT_ERROR\",\n\n    evaluated = \"RESULT_EVALUATED\",\n\n    validated = \"RESULT_VALIDATED\",\n}\n\nexport type IPipelineRequire = (name: string) => any;\n\nexport type IPipelineUpdater = (value: string) => string;\n\nexport interface IPipelineContext {\n    [key: string]: any;\n}\n\nexport interface IPipelineImports {\n    [key: string]: any;\n}\n\nexport interface IPipelineModule<T = any> {\n    exports: T;\n}\n\nexport interface IPipelineOptions {\n    context: IPipelineContext;\n\n    imports: IPipelineImports;\n\n    mode: PIPELINE_MODES;\n}\n\nexport interface IPipelineResult {\n    type: PIPELINE_RESULT_TYPES;\n}\n\nexport interface IPipelineEvaluated<T> extends IPipelineResult {\n    module: IPipelineModule<T>;\n\n    type: PIPELINE_RESULT_TYPES.evaluated;\n}\n\nexport interface IPipelineError extends IPipelineResult {\n    message: string;\n\n    type: PIPELINE_RESULT_TYPES.error;\n}\n\nexport interface IPipelineValidated extends IPipelineResult {\n    type: PIPELINE_RESULT_TYPES.validated;\n}\n\n// HACK: Since the `Writable` uses the `T` generic for I/O on `set` / `update`, we\n// need to just redefine it here ourselves\nexport interface IPipelineStore<T>\n    extends Readable<IPipelineError | IPipelineEvaluated<T> | IPipelineValidated | null> {\n    set(value: string): void;\n\n    update(updater: IPipelineUpdater): void;\n}\n\nexport function evaluate_code<T = any>(\n    script: string,\n    context: IPipelineContext\n): [boolean, IPipelineModule<T> | string] {\n    const keys = Object.keys(context);\n    const values = Object.values(context);\n\n    // @ts-ignore\n    const module: IPipelineModule<T> = {exports: {}};\n\n    Object.seal(module);\n\n    try {\n        const func = new Function(\n            ...keys,\n            \"module\",\n            \"exports\",\n            `return (function () {\n                \"use strict\";\n                ${script}\n            })`\n        )(...values, module, module.exports);\n\n        func();\n    } catch (err) {\n        return [false, err.message];\n    }\n\n    return [true, module];\n}\n\nexport function make_require(imports: IPipelineImports = {}): IPipelineRequire {\n    return (name) => {\n        if (name in imports) return imports[name];\n        throw new ReferenceError(\"bad argument #0 to 'require' (module '${name}' not found)\");\n    };\n}\n\nexport function validate_code(script: string): [boolean, string?] {\n    try {\n        new Function(script);\n    } catch (err) {\n        return [false, err.message];\n    }\n\n    return [true];\n}\n"],
  "mappings": ";;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEO,IAAK;AAAL,UAAK;AACR,gCAAW;AAEX,gCAAW;AAAA,GAHH;AAML,IAAK;AAAL,UAAK;AACR,oCAAQ;AAER,wCAAY;AAEZ,wCAAY;AAAA,GALJ;AA6DL,uBACH,QACA;AAEA,QAAM,OAAO,OAAO,KAAK;AACzB,QAAM,SAAS,OAAO,OAAO;AAG7B,QAAM,UAA6B,CAAC,SAAS;AAE7C,SAAO,KAAK;AAEZ;AACI,UAAM,OAAO,IAAI,SACb,GAAG,MACH,UACA,WACA;AAAA;AAAA,kBAEM;AAAA,iBAER,GAAG,QAAQ,SAAQ,QAAO;AAE5B;AAAA,WACK;AACL,WAAO,CAAC,OAAO,IAAI;AAAA;AAGvB,SAAO,CAAC,MAAM;AAAA;AAGX,sBAAsB,UAA4B;AACrD,SAAO,CAAC;AACJ,QAAI,QAAQ;AAAS,aAAO,QAAQ;AACpC,UAAM,IAAI,eAAe;AAAA;AAAA;AAI1B,uBAAuB;AAC1B;AACI,QAAI,SAAS;AAAA,WACR;AACL,WAAO,CAAC,OAAO,IAAI;AAAA;AAGvB,SAAO,CAAC;AAAA;",
  "names": []
}
